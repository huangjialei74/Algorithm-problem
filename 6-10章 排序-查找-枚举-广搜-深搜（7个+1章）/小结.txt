输入数据： 如果是递归数据结构，如单链表，二叉树，集合，则百分之百可以用深搜，如果非递归数据结构，如一维数组，二维数组，字符串，图，则概率小一些。
求解目标： 必须走到最深（例如对于树，必须要走到叶子节点）才能得到一个解，这种情况适合深搜

思考步骤：
1.
（a）如果求路径条数 ，则不需要存储路径
（b）如果是求路径本身，则需要用一个path[]存储路径，搜索过程中始终只有一条路径，用一个数组就 足够了
2.求一个解，那找到了就可以返回；求所有解，得遍历完；
3.终止条件 是到了不能扩展的末端节点，对于树是叶子节点，对于图或隐式图，是出度为0的节点
4.收敛条件 找到了合法解的时刻
5.是否判重？树在遍历过程中不可能重复  ， 如果状态转换图是DAG, 则需要判重
6.加速  ：剪枝： 成本小收益大，加几行代码能大大加速
缓存 ：前提条件，状态转换图是DAG, DAG->存在重叠问题->子问题的解会被重复利用，用缓存自然会有加速效果，树状的依赖关系没必要加缓存（因为没重复，用不到）
void dfs(type &input, type &path, type &result, int cur or gap)
{
if(数据非法) return 0;//终止条件
if(cur==input.size()){//收敛条件
//if(gap==0){
将path放入result
}
if(可以剪枝return;
for(...){//执行所有可能的扩展操作修改path
dfs(input,  step+1 or gap--, result);
恢复path
}
}